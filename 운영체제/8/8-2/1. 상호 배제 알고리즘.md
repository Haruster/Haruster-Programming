# 상호 배제 알고리즘

- 임계 구역 문제에 대한 해결책이 충족되어야 할 세 가지 요건

    > 상호 배제 : 한 프로세스가 그들의 임계 구역에서 실행되고 있다면 다른 프로세스는 그 임계 구역에 들어갈 수 없다.

    > 진행 : 임계 구역에서 실행 중인 프로세스가 없을 때 그 임계 구역으로 진입하려는 프로세스가 있을 경우, 임계 구역이 아닌 곳에서 실행 중인 프로세스들만 임계 구역으로의 진입을 결정하는데 참여할 수 있으며, 이 선택은 무한 연기되어서는 안된다.

    > 한정된 대기 : 어떤 프로세스가 임계 구역에 진입을 요청한 이후부터 그 요청이 허용될 때까지 다른 프로세스들의 임계 구역 진입 허용 횟수에 한계가 있어야 한다. 이 한계는 임의의 프로세스의 기아(STARVATION)을 예방할 수 있다.


    ## 1단계 알고리즘

        do {

            while (turn != i);

                critical section

            turn = j;

                remainder section

        } while (1);

        > 프로세스 Pi

        do { 

            while (turn != j);

                critical section

            turn = i;

                remainder section

        } while (1);

        > 프로세스 P

- 프로세스들이 임계 구역을 교대로 수행하도록 되어 있기 때문에 진행 조건이 충족되지 않는다.


    ## 2단계 알고리즘

    - 프로세스의 상태에 관한 정보를 유지하기 위하여 turn 변수를 배열로 변경한다.

        > boolean flag[2];
        > 만일 flag[i]의 값이 true라면 Pi가 임계 구역에 진입할 준비가 되었다는 뜻이다.

            do {

                flag[i] = true;

                while(flag[j]);

                    Critical Section

                flag[i] = false;

                    Remainder Section

            } while(1);


            do {

                flag[j] = true;

                while (flag[i]);

                    Critical Section

                flag[j] = false;

                    Remainder Section

            } while(1);

- 진행 조건이 충족되지 않는다.


## 3단계 알고리즘

- 3가지 모든 요구조건을 만족시키는 해결책

    > boolean flag[2];  

        int turn;

    > flag[0]과 flag[1]의 초깃값은 false가 되지만, turn의 초깃값은 0과 1중 어느 한 값으로 초기화된다.


        do {

            flag[i] = true;

            turn = j;

            while (flag[j] and turn == j);

                Critical Section

            flag[i] = false;

                Remainder Section

        } while(1);


        do {

            flag[j] = true;

            turn = i;

            while(flag[i] and turn == i);

                Critical section

            flag[j] = false;

                Remainder Section

        } while(1);


- flag[i]와 flag[j] 모두 참인 경우

    > tur의 최종 값이 두 프로세스 중에서 하나만을 임계 구역에 먼저 진입하도록 허용한다.

    - Peterson의 알고리즘이라고도 한다.



## Dekker의 알고리즘

- 공유 변수

        > flag[i] false, falg[j] = false

          turn 0


- 의사 코드

    ex) 프로세스 pi

        do { 

            flag[i] = true;

            while(flag[j])

                if(turn = j) {

                    flag[i] = false;

                    while(turn = j);

                    flag[i] = true;

                }

                // critical section

                turn = j;

                flag[i] = false;

                // remainder section

        } while(1);

    
    ex) 프로세스 pj

        do {

            flag[j] = true;

            while(flag[i]) 

                if(turn = i) {

                    flag[j] = false;

                    while(turn = i);

                    flag[j] = true;

                }

                // critical section

                turn = i;

                flag[i] = false;

                // remainder section

        } while(1);

- 3가지 모든 요구 조건을 만족시키는 해결책

- Peterson의 알고리즘과 차이

    > 두 프로세스가 모두 임계 영역에 들어가려고 할 때 Peterson에서는 프로세스가 "I enter"라고 하고 Dekker에서는 프로세스가 "You may enter"라고 한다.


### n개 프로세스의 상호 배제 알고리즘

- Lamport의 Bakery 알고리즘

        // 광역 변수의 선언과 초기 값들

        Entering: array [1..NUM_THREADS] of bool = {false};
        Number: array [1..NUM_THREADS] of integer = {0};

        lock(integer i) {

        Entering[i] = true;
        Number[i] = 1 + max(Number[1], ..., Number[NUM_THREADS]);
        Entering[i] = false;

        for(integer j = 1; j <= NUM_THREADS; j++) {

            // 프로세스 j가 번호표를 받을 때까지 대기

            while(Entering[j]) {/* nothing */}

            // 작은 번표표를 갖거나 같은 번호이지만 높은 우선순위를 갖는 프로세스들이 작업을 완료할 때까지 대기

            while((Number[j] != 0) && ((Number[j], j) < (Number[i], i))) {/* nothing */}

        }

        }


        unlock(integer i) {

            Number[i] = 0;

        }

        Thread(integer i) {

            while(true) {

                lock(i);

                // 임계 지역

                unlock(i);

                // 비임계 지역

            }

        }

> 3가지 요구 조건을 만족한다.