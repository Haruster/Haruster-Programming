# 파일 시스템

- 운영체제가 사용자에게 제공하는 가장 직접적인 서비스 형태

- 파일 시스템은 두 부분으로 구성된다.
    > 관련된 정보를 포함하는 실제적인 파일들의 집합체
    > 시스템 내의 모든 파일에 대한 정보를 제공하는 디렉터리 구조

- 각종 정보를 논리적 저장 단위인 파일(file)로 추상화하여 실제 기억장치 상에 사상(Mapping)

- 파일은 작성자에 의해 정의된 상호 관련이 있는 정보의 집합체이다.
    > 보통 보조기억장치 속에 저장
    > 대개 프로그램이나 데이터로 구성된다.
    > 일반적으로 작성자와 사용자에 의해 그 의미가 정의된 비트, 바이트, 행(Line), 또는 레코드들의 연속체
    > 하나의 파일에는 여러 속성을 가진다. (파일의 이름(name), 형태(type), 작성 시기, 작성자, 길이 등)


## 데이터 계층 구조

- 필드 (field) : 상호 관련 있는 문자들(숫자, 영문자, 특수 기호 등0의 집합

- 레코드(record) : 서로 관련이 있는 필드들의 집합

- 레코드 키 (record key) : 어떤 레코드를 다른 레코드들로부터 식별하는데 사용되는 제어필드(Control Field)이다.

- 파일(file) : 상호 관련 있는 레코드들의 집합

- 데이터베이스(database) : 데이터 계층 구조에서 가장 높은 계층으로 상호 관련 있는 파일들로 구성


## 블로킹

- 블록 (Block) : 기억매체에 출력되거나 기억매체로부터 입력되는 실제 정보의 단위인 물리적 레코드(Physical Record)

- 논리적 레코드(Logical Record) : 사용자 관점에서 취급되는 자료 집단의 단위

- 블로킹되지 않은 레코드(Unblocked Record)로 구성된 파일 : 물리적 레코드가 단 하나의 논리적 레코드로 구성

- 고정 길이 레코드(fixed-length record) : 구성된 파일에서의 레코드 길이는 모두 같고, 블록의 크기는 일반적으로 레코드 크기의 정수 배

- 가변 길이 레코드(variable-length record) : 구성된 파일에서의 레코드 길이는 다양하고, 블록의 크기는 레코드의 최대 크기와 동일할 수 있다.



## 파일 시스템의 기능

> 사용자가 파일을 생성(create), 수정(modify), 삭제(delete) 기능

> 다른 사용자의 파일을 공동으로 사용할 수 있도록 적저란 제어 방법을 제공한다.

> 파일 공유를 위하여 판독 접근, 기록 접근, 수행 접근, 또는 이들을 적당히 조합한 것 등 여러 가지 접근 제어 방법을 제공한다.

> 사용자가 자신의 응용 분야에 적합한 형태로 파일을 구성할 수 있다.

> 본의 아닌 또는 고의적인 정보의 손실이나 파괴를 방지하기 위하여 백업(backup)과 복구(recovery)를 위한 기능

> 사용자가 물리적 장치 이름 대신 기호화된 이름(symbolic name)을 사용하여 해당 파일을 참조한다.

> 정보의 암호화(encryption)와 복호화(decryption)를 할 수 있는 능력

> 사용자에게 친숙한 인터페이스(user friendly interface)를 제공
    - 사용자는 데이터와 이들 데이터에 관련된 작업에 대하여 물리적 구조가 아닌 논리적 구조를 제공한다.

    - 사용자는 데이터가 저장되어 있는 특정 장치, 데이터의 기억된 형태, 데이터 전송 방식 등에 대해 관여할 필요가 없다.


## 파일의 구조

- 파일을 구성하는 레코드들이 보조기억장치에 배치되는 방법이다.

- 파일에 대한 접근 방법과도 밀접한 관계를 가진다.

### 구성 방식

    순차 파일

        - 논리적인 레코드를 물리적인 순서에 따라 순차적으로 저장하고 검색하도록 저장한다.
        - 다음 레코드는 실제로 현 레코드의 바로 뒤에 저장한다.
        - 순차적 특징을 가지는 기억 매체에 파일을 저장할 때 사용한다.
        - 디스크, 자기 테이프, 프린터로 된 출력등에 주로 사용한다.
        - 순차 파일은 순차 접근 기억 장치(SASD : Sequential Access Storage Device)에 저장된다.
        - 일괄처리에서 많이 사용된다.
        - 논리적인 레코드를 물리적인 순서에 따라 순차적으로 저장하고 검색하도록 저장한다.

        장점 : 다음 레코드에 빠른 접근이 가능하다.
        단점 : 순차 파일에 대한 접근 방식이 파일에 저장된 레코드 순서와 다를 때 프로그램의 접근 속도가 저하된다.


### 색인된 순차 파일(indexed sequential file)

- 순차 및 직접 접근을 모두 처리할 수 있는 파일 구조이다.

- 순차 파일과 직접 파일을 결합한 형태이다.

- 레코드는 각 레코드와 키 값에 따라 논리적 순으로 배열된다.

- 레코드는 키 값에 순차적으로 접근할 수도 있고, 시스템에 의해 관리되는 인덱스 블록의 검색을 통하여 직접 접근될 수도 있다.

- 보통 디스크와 같은 직접 기억 장치(DASD : Direct Access Storage Device)에 저장한다.

- 일괄 처리 및 대화형 처리를 목적으로 하는 파일을 지원한다.

장점 : 파일 구조가 융통성이 많고 검색 기능도 우수하다.
단점 : 설계 시 고려할 사항이 많다.


### 직접 파일 (Direct file)

- 다른 레코드를 참조하지 않고 임의 레코드를 직접 접근할 수 있는 파일 구조이다.

- 레코드가 직접 접근 기억장치의 물리적 주소를 통해 직접 접근한다.

- 특정 레코드를 검색하기 위해서는 키 값에서 보조기억장치의 주소로 사상시키는 사상 함수가 필요하다.

- 특정 레코드를 저장하고 있는 기억장소의 주소를 신속하게 계산한다.

- 대화형 처리에 유용하다.

- 디스크와 같은 직접 접근 기억장치(DASD : Direct Access Storage Device)에 저장한다.

장점 : 다른 레코드에 영향을 주지 않고, 특정 레코드의 검색, 삽입, 수정, 삭제가 쉽다.
단점 : 키 값의 순서에 의한 순차 검색이 어렵다.


### 파일 공간의 할당과 회수

> 파일을 구성하는 레코드들이 보조기억장치에 배치되는 방법

> 보조기억장치 상의 공간은 작은 공간들로 단편화(Fragmentation)되는 현상이 발생한다.
    - 주기적인 집약(Compaction)을 수행

> 파일에 대한 접근 방법과도 밀접한 관계를 가진다.


#### 비트벡터

- 각 디스크 블록 당 하나의 비트가 할당되어서 관리하는 방법이다.

    > i번째 비트는 시스템의 i번째 블록이다.
    > 해당 블록이 자유 공간이면, 1로 표현되고, 0이면 파일이 할당되어 있는 공간이다.

ex)

    0000100111001.........


장점 : 자유 블록이나 연속된 자유 블록들을 찾기 쉽다.

- 1의 개수가 연속적으로 n개 있으면, n개의 연속된 자유 블록이 있다는 것을 의미한다.

- 주기억장치에 위치하고 있으며, 리눅스 운영체제의 자유 공간 관리에 비트 벡터를 사용한다.


#### 연속 할당

- 파일들이 보조기억장치 내의 연속적으로 인접된 공간에 할당되는 것이다.

- 연속 할당 시스템에서의 파일 디렉터리는 파일의 시작주소와 파일 길이(length)만을 가진다.

##### 장점 

- 연속적으로 논리적 블록들이 디스크 상의 전체에 분산되어 있는 시스템과 비교할 때 훨씬 빠른 접근이 가능하다.

##### 단점 

- 사용자가 새로운 파일을 생성하기 위해서는 필요한 공간의 크기를 미리 명시해야 한다.

- 만약 원하는 만큼의 기억 공간이 확보되지 않으면 해당 파일은 생성되지 못한다.

- 단편화(Fragment) 문제 발생

- 보조기억장치 내의 인접한 공간은 병합되어야 하고, 새로운 파일이 저장되기에 충분한 기억장소를 확보하기 위하여 주기적인 집약이 필요하다.


#### 불연속 할당 : 연결 리스트

- 동일 파일에 속해 있는 섹터(Sector)들이 서로 연결 리스트의 형태를 취하면서 다른 것과의 연결을 위한 포인터(Pointer)를 가지고 디스크 전체에 분산

- 디렉터리에는 처음 해당 파일이 시작되는 시작 주소 및 마지막 주소에 대한 포인터(Pointer)가 있다.

##### 문제점

- 파일의 블록들이 디스크 전체에 분산되어 있기 때문에 논리적으로 연속된 블록들의 검색에는 긴 시간이 요구된다.

- 연결리스트 구조를 유지하는데 필요한 시간이 추가적으로 소요된다.

- 연결된 리스트 내에 있는 포인터들은 파일 데이터를 위한 가용 공간을 감소시킨다.


#### 불연속 할당 : 색인 블록

- 각 파일마다 하나의 색인 블록(indexed block)을 두고, 여기에 파이르이 블록 항목이 산재해 있는 주소에 대한 포인터를 모아둔다.

- 각 파일의 색인 블록은 고정된 수의 항목을 가지고 있으며, 또 각 항목은 블록 식별자(Identifier)와 블록 포인터를 가진다.

- 단편화의 문제 없이 해당 블록에 대한 직접 접근이 가능하다.

- 연결 리스트 방법보다 기억 장소의 낭비를 더 초래할 수도 있다.
    - 두개의 섹터를 가지는 파일에 대하여 색인 블록 방법에서는 두 포인터만을 사용하는 블록의 나머지 부분은 낭비된다.


### 파일의 보호 (Protection)

- 물리적인 손상으로의 보호(신뢰성의 문제)와 파일에서의 부당한 접근으로부터의 보호(보호의 문제)

- 보호 기법

#### 파일 이름 (naming)

    - 다른 사용자 파일의 이름은 알 수 없고, 그 이름을 추측하기도 어렵다는 가정에 근거
    - 다른 사용자 파일의 이름을 알지 못하는 경우에는 접근 대상에서 제외된다.

#### 암호 (Password)

    - 각 사용자마다 서로 다른 암호를 제공하여 그 암호를 알아야만 파일을 이용할 수 있게 하는 방법이다.

장점 : 보호 목적으로 작은 노력과 기억장소가 소요된다.
단점 : 파일의 보호가 불확실, 쉽게 노출될 수 있음, 불법 사용자가 바뀐 암호를 사용할 수 있음.


#### 파일 이름(naming)

    - 사용자에 따라 접근이 가능한 유형을 다르게 명시
    - 각 파일이나 디렉터리에 명시된 접근 가능한 사용자와 가능한 동작을 운영체제가 참조하여 접근 여부를 결정한다.
    - UNIX 시스템
        세 종류의 접근 유형 : (r : read, w : write, x : execute)
        세 종류의 사용자 유형 : (파일 소유자, 그룹 사용자, 모든 사용자)
        