# 모니터

- 모니터란 순차적으로만 사용할 수 있는 특정 공유자원이나 공유자원 그룹을 할당하는데 사용되는 것을 말한다.

- 필요한 데이터 및 프로시저를 포함하는 병행성 구조(Concurrency Construct)이다.

    > 공유 자원에 접근하고자 하는 프로세스는 반드시 특정 모니터의 진입부(Entry)를 호출한다.
    > 사용 중인 모니터에 들어가려고 하는 프로세스는 반드시 대기한다.

- 데이터와 이들 데이터를 처리하는 프로시저의 집합이다.



- 모니터 선언 형식의 구조

    monitor : monitorname 

    {

        declaration of private date;        /* local monitor variables */

        void pub_name(formal parameters) { /* public procedure */ 

            procedure_body;}

        void priv_name(formal parameters) { /* private procedure */ 
        
            procedure_body; }

        {

            Initialization of monitor data;

        }

    }




- 모니터를 이용한 간단한 자원 할당의 예


    monitor : resource_allocator

    boolean     resource_in_use;

    condition   resource_is_free;

    void get_resource(int time) {

        if (resource_in_use) 

            resource_is_free.wait(time);

        resource_in_use = true;

    }

    void return_resource() {

        resource_in_use = false;

        resource_is_free.signal();

    }

    {

        resource_in_use = false;

    }
 

 ## 환영 버퍼를 이용한 생산자 / 소비자 문제

 - 환영 버퍼에서 생산자 / 소비자 문제에 댛나 모니터 사용 예

        monitor : ring_buffer_monitor

        char ring_buffer[N];

        int slot_in_use, next_slot_to_fill, next_slot_to_empty;

        condition ring_buffer_has_data, ring_buffer_has_space;

        void fill_a_slot(char x) {

            if (slot_i _use == N) wait(ring_buffer_has_space);

            ring_buffer[next_slot_to_fill] = x;

            slot_in_use = slot_in_use + 1;

            next_slot_to_fill = (next_slot_to_fill + 1) mod N;

            signal(ring_buffer_has_data);

        }

        void empty_a_slot(char x) {

            if (slot_in_use == 0) wait(ring_buffer_has_data);

            x = ring_buffer[next_slot_to_empty];

            slot_in_use = slot_in_use - 1;

            next_slot_to_empty = (next_slot_to_empty + 1) mod N;

            signal(ring_buffer_has_space);

        }

        {

            slot_in_use = 0;

            next_slot_to_fill = 0;

            next_slot_to_empty = 0;

        }



## 읽기 쓰기 문제

- 읽기 / 쓰기 문제에 대한 모니터 사용(읽기 우선)


        monitor : readers_and_writers

        int readers;

        boolean someone_is_writing;

        condition reading_allowed, writing_allowing;

        void begin_reading() {

            if (someone_is_writing || queue(writing_allowed)) wait(reading_allowed);

            readers = readers + 1;

            signal(reading_allowed);

        }

        void finished_reading() {

            readers = readers - 1;

            if (readers == 0) signal(writing_allowed);

        }

        void begin_writing() {

            if (readers > 0 || someone_is_writing) wait(writing_allowed);

            someone_is_writing = true;

        }

        void finished_writing() {

            someone_is_writing = false;

            if(queue(reading_allowed)) signal(reading_allowed);

            else signal(writing_allowed);

        }

        {

            readers = 0;

            someone_is_writing = false;

        }



## 동기화 메커니즘의 종류

- 공유 메모리 방식 : 병목(bottleneck) 현상이 발생하고 또한, 공유 변수가 파괴되었을 때 전체 시스템의 기능이 현저하게 저하되는 결과가 발생한다.

- 메시지 전달 방식 : 컴퓨터 네트워크에서 노드 간의 통신은 주로 메시지를 주고 받음으로써 이루어지고, 이는 프로세스 간 통신 및 동기화를 자연스럽게 지원(분산시스템에 적합하다.)


### 메시지

> 송신측 프로세서와 수신측 프로세스 간에 교환될 수 있는 정보의 집합이다.


### 메시지 실행 시 고려 사항

- 네이밍(naming) 문제

    > 직접 네이밍 방식 : 메시지 전송 시에 송신자가 수신자를 설정해야 하고, 반대로 메세지 수신을 희망하는 수신자는 송신자를 설정한다.

    > 간접 네이밍 방식 : 메시지가 우편함에 송신되고 또 그 우편함으로부터 수신된다.


- 복사 문제

- 버퍼링 문제

    > 비동기적 통신을 가능하게 하기 위해서는 버퍼링이 필요하다

- 길이 문제

    > 메시지의 길이를 고정적으로 할 것인지 또는 가변적으로 할 것인지를 결정한다.


    > 고정 길이 메시지 

        - 구현이 용이하나, 버퍼의 크기에 비하여 메시지가 작을 경우 버퍼의 낭비를 초래한다.
        - 메시지가 클 경우에는 메시지를 분할하여 전송해야 하는 문제점이 발생한다.

    > 가변 길이 메시지

        - 크기에 맞추어 동적으로 버퍼를 생성하는 것으로 구현이 복잡하지는 하나 높은 적용력을 가진다.


## 유한 버퍼에서 메시지 전달을 사용한 생산자 / 소비자 문제에 대한 해결책

    const int

        capacity = /* buffering capacity */;

        null =  /* empty message */;

        int i;

        void producer() {

            message pmsg;

            while(true) {

                receive (mayproduce, pmsg);

                pmsg = produce();

                send (mayconsume, pmsg);

            }

        }

        void consumer() {

            message cmsg;

            while(true) {

                receive (mayconsume, cmsg);

                consume (cmsg);

                send (mayproduce, null);

            }

        }
        
    
    void main() {

        create_mailbox (mayproduce);

        create_mailbox (mayconsume);

        for (int i = 1; i <= capacity; i++) send (mayproduce, null);

        parbegin (producer, consumer);

    }