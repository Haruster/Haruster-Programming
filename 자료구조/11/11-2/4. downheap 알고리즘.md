# downheap 알고리즘

    delete_max_heap(A):

    item <- A[1];

    heap_size <-heap_size-1;

    i <- 2;

    while 1 <= heap_size do

        if i < heap_size and A[i+1] > A[i]

            then largest <- i + 1;
            else largest <- i;

        if A[PARENT(largest)] > A[largest]

            then break;

        A[PARENT(largest)] <-> A[largest];

        i <- CHILD(largest);

    return item;


## 삭제 프로그램

    // 샥제 함수

    element delete_max_heap(HeapType *h) {

        int parent, child;

        element item, temp;

        item = h->heap[1];

        temp = h->head[(h->heap_size)--];

        parent = 1;

        child = 2;

        while(child <= h->heap_size) {

            // 현재 노드의 자식노드 중 더 큰 자식 노드를 찾는다.

            if ((child < h->heap_size) && (h->heap[child].key) < h->heap[child+1].key) {

                child++;

            }

            if(temp.key >= h->heap[child].key) break;

            // 한 단계 아래로 이동

            h->heap[parent] = h->heap[child];

            parent = child;

            child *= 2;

        }

        h->heap[parent]= temp;

        return item;

    }

    