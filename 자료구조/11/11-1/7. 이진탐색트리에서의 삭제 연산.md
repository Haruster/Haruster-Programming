# 이진탐색트리의 삭제 연산

- 3가지의 경우

    1. 삭제하려는 노드가 단말 노드일 경우

    2. 삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리 중 하나만 가지고 있는 경우

    3. 삭제하려는 노드가 두 개의 서브 트리 모두 가지고 있는 경우

- CASE 1: 삭제하려는 노드가 단말 노드일 경우: 단말 노드

- CASE 2: 삭제하려는 노드가 하나의 서브트리만 갖고 있는 경우 : 삭제되는 노드가 왼쪽이나 오른쪽 서브 트리 중 하나만 갖고 있을 때, 그 노드는 삭제하고 서브 트리는 부모 노드에 붙여준다.

- CASE 3: 삭제하려는 노드가 두 개의 서브 트리를 갖고 있는 경우 : 삭제노드와 가장 비슷한 값을 가진 노드를 삭제노드 위치로 가져온다.



## 이진 탐색 트리에서의 삭제 연산

    // 이진 탐색 트리와 키가 주어지면 키가 저장된 노드를 삭제하고 새로운 루트 노드를 반환한다.

    TreeNode* delete_node(TreeNode* root, int key) {

        if (root == NULL) return root;

        // 만약 키가 루트보다 작으면 왼쪽 서브 트리에 있는 것임

        if (key < root->key) {

            root->left = delete_node(root->left, key);

        }

        // 만약 키가 루트보다 크면 오른쪽 서브 트리에 있는 것임

        else if (key > root->key) {

            root->right = delete_node(root->right, key);

        }

        // 키가 루트와 같으면 이 노드를 삭제하면 된다.

        else {

            // 첫 번째나 두 번째 경우

            if (root->left == NULL) {

                TreeNode *temp = root->right;

                free(root);

                return temp;

            }

            else if (root->right == NULL) {

                TreeNode *temp = root->left;

                free(root);

                return temp;

            }

            // 세 번째 경우

            TreeNode *temp = min_value_node(root->right);


            // 중외 순회시 후계 노드를 복사한다.

            root->key = temp->key;

            // 중외 순회시 후계 노드를 삭제한다.

            root->right = delete_node(root->right, temp->key);

        }

        return root;

    }


## 이진탐색트리의 삭제 연산 - 계속

    TreeNode *min_value_node(TreeNode *node) {

        TreeNode *current = node;

        // 맨 왼쪽 단말 노드를 찾으러 내려감

        while(current->left != NULL) {

            current = current->left;

        }

        return current;

    }


## 이진탐색트리에서 탐색 예제

    int main(void) {

        TreeNode *root = NULL;
        TreeNode *tmp = NULL;

        root = insert_node(root, 30);
        root = insert_node(root, 20);
        root = insert_node(root, 10);
        root = insert_node(root, 40);
        root = insert_node(root, 50);
        root = insert_node(root, 60);

        printf("이진 탐색 트리 중위 순회 결과 \n");

        inorder(root);

        if (search(root, 30) != NULL) {

            printf("이진 탐색 트리에서 30을 발견함 \n");

        }

        else {

            printf("이진 탐색 트리에서 30을 발견 못함 \n");

        }

        return 0;


    }