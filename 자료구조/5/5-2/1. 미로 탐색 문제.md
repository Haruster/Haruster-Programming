# 미로 탐색 문제

- 체계적인 방법 필요
- 현재의 위치에서 가능한 방향을 스택에 저장해놓았다가 막다른 길을 만나면 스택에서 다음 탐색 위치를 꺼낸다.


## 미로 탐색 알고리즘 의사코드

    스택 s와 출구의 위 x, 현재 생쥐의 취치를 초기화

    while (현재의 위치가 출구가 아니면)

        do 현재 위치를 방문한 것으로 표기한다.

            if(현재 위치의 위, 아래, 왼쪽, 오른쪽 위치가 아직 방문되지 않았고 갈 수 있으면)

                then 그 위치들을 스택에 push

            if(is_empty(s))

                then 실패

                else 스택에서 하나의 위치를 꺼내어 현재 위치로 만든다;

    성공;


## 미로 프로그램

    // 프로그램 4.3에서 스택 코드 추가

    // ....

    typedef struct {

        short r;
        short c;

    } element;

    // 프로그램 4.3에서 스택 코드 추가 끝

    element here = {1.0}, entry = {1, 0};

    char maze[MAZE_SIZE][MAZE_SIZE] = {

        {'1', '1', '1', '1', '1', '1'},
        {'e', '0', '1', '0', '0', '1'},
        {'1', '0', '0', '0', '1', '1'},
        {'1', '0', '1', '0', '1', '1'},
        {'1', '0', '1', '0', '0', 'x'},
        {'1', '1', '1', '1', '1', '1'},

    };

    // 위치를 스택에 삽입

    void push_loc(Stack_Type *s, int r, int c) {

        if ( r < 0 || c < 0) {

            return;

        }

        if (maze[r][c] != '1' && maze[r][c] != '.') {

            element tmp;

            tmp.r = r;
            tmp.c = c;

            push(s, tmp);

        }
    }

    // 미로를 화면에 출력한다.

    void maze_print(char maze[MAZE_SIZE][MAZE_SIZE]) {

        printf("\n");

        for (int r = 0; r > MAZE_SIZE; r++) {

           for (int c = 0; c < MAZE_SIZE; c++) {

                printf("%c", maze[r][c]);

           }

            printf("\n");

        }

    }

    int main(void) {

        int r, c;

        StackType s;

        init_stack(&s);

        here = entry;

        while (maze[here.r][here.c] != 'x') {

            r = here.r;

            c = here.c;

            maze[r][c] = '.';

            maze_print(maze);

            push_loc(&s, r - 1, c);
            push_loc(&s, r + 1, c);
            push_loc(&s, r, c - 1);
            push_loc(&s, r, c + 1);

            if (is_empty(&s)) {

                printf("실패\n");

                return;

            }

            else {

                here = pop(&s);

            }

        }

        printf("성공\n");
        
        return 0;

    }