# 리스트

    L = (item0, item1, item2, ... item n-1)

- 리스트에 새로운 항목을 추가한다. (삽입 연산)

- 리스트에서 항목을 삭제한다. (삭제 연산)

- 리스트에서 특정한 항목을 찾는다. (탐색 연산)


## 리스트 추상 데이터 타입

     객체 : n개의 element형으로 구성된 순서 있는 모임

     연산 :

    - insert(list, pos, item) ::= pos 위치에 요소를 추가한다.
    - insert_last(list, item) ::= 맨 끝에 요소를 추가한다.
    - insert_first(list, item) ::= 맨 처음에 요소를 추가한다.
    - delete(list, pos) ::= pos 위치의 요소를 제거한다.
    - clear(list) ::= 리스트의 모든 요소를 제거한다.
    - get_entry(list, pos) ::= pos 위치의 요소를 반환한다.
    - get_length(list) ::= 리스트의 길이를 구한다.
    - is_empty(list) ::= 리스트가 비었는지를 검사한다.
    - is_full(list) ::= 리스트가 꽉 찼는지를 검사한다.
    - print_list(list) ::= 리스트의 모든 요소를 표시한다.


## 리스트 구현 방법

1. 배열을 이용한 구현 방법

2. 연결리스트를 이용한 구현 방법


### 배열로 구현된 리스트

- 배열을 이용하여 리스트를 구현하면 순차적인 메모리 공간이 할당되므로, 이걸을 리스트의 순차 표현(sequential representation)이라고 한다.


#### ArrayListType의 구현

    #define MAX_LIST_SIZE 100 // 리스트의 최대 크기

    typedef int element; // 항목의 정의

    typedef struct {

        element array[MAX_LIST_SIZE]; // 배열 정의

        int size; // 현재 리스트에 저장된 항목들의 개수

    } ArrayListType;


    void error(char *message) {

        fprintf(stderr, "%s\n", message);
        exit(1);

    }

    // 리스트 초기화 함수

    void init(ArrayListType *L) {

        L->size = 0;

    }

    // 리스트가 비어 있으면 1을 반환하고 그렇지 않으면 0을 반환한다.

    int is_full(ArrayListType *L) {

        return L->size == MAX_LIST_SIZE;

    }

    element get_entry(ArrayListType *L, int pos) {

        if (pos < 0 || pos >= L->size) {

            error("위치 오류");

        }

        return L->array[pos];

    }

    // 리스트 출력

    void print_list(ArrayListType *L) {

        int i;

        for(i = 0; i < L->size; i++) {

            printf("%d->", L->array[i]);

        }

        printf("\n");

    }

    void insert_last(ArrayListType *L, element item) {

        if(L ->size >= MAX_LIST_SIZE) {

            error("리스트 오버플로우");

        }

        L->array[L->size++] = item;

    }

    void insert(ArrayListType *L, int pos, element item) {

        if(!is_full(L) && (pos >= 0) && (pos <= L->size)) {

            for(int i = (L->size -1); i >= pos; i--) {

                L->array[i + 1] = L->array[i];

            }

            L->array[pos] = item;
            L->size++;

        }

    }

    element delete(ArrayListType *L, int pos) {

        element item;

        if(pos < 0 || pos >= L->size) {

            error("위치 오류");

        }

        item = L->array[pos];

        for (int i = pos; i < (L->size -1); i++) {

            L->array[i] = L->array[i + 1];
        
        }

        L->size--;

        return item;

    }

    int main(void) {

        // ArrayListType을 정적으로 생성하고 ArrayListType을 가리키는 포인터를 함수의 매개변수로 전달한다.

        ArrayListType list;

        init(&list);

        insert(&list, 0, 10);   print_list(&list); // 0번째 위치에 10추가
        insert(&list, 0, 20);   print_list(&list); // 0번째 위치에 20추가
        insert(&list, 0, 30);   print_list(&list); // 0번째 위치에 30추가

        insert_last(&list, 40);  print_list(&list); // 맨 끝에 40추가

        delete(&list, 0);   print_list(&list);  // 0번째 항목 삭제

        return 0;

    }