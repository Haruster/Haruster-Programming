# 연결된 표현

- 리스트의 항목들을 노드(Node)라고 하는 곳에 분산하여 저장한다.

- 노드는 데이터 필드와 링크 필드로 구성한다.

    > 데이터 필드 - 리스트의 원소, 즉 데이터 값을 저장하는 곳이다.
    > 링크 필드 - 다른 노드의 주소 값을 저장하는 장소(포인터)

## 삽입과 삭제가 효율적이다.


## 연결된 표현의 장단점

- 장점

    > 삽입, 삭제가 보다 용이하다.
    > 연속된 메모리 공간이 필요없다.
    > 크기 제한이 없다.

- 단점

    > 구현이 어렵다.
    > 오류가 발생하기 쉽다.


## 노드의 구조

- 노드 = 데이터 필드 + 링크 필드


## 연결 리스트의 종류

- 단순 연결 리스트

- 원형 연결 리스트

- 이중 연결 리스트


### 단순 연결 리스트

- 하나의 링크 필드를 이용하여 연결한다.

- 마지막 노드의 링크 값은 NULL이다.

#### 노드의 정의

    typedef int element;

    typedef struct ListNode { // 노드 타입을 구조체로 정의한다.
    
        element data;

        struct ListNode *link;

    } ListNode;


#### 리스트의 생성

    ListNode *head = NULL;

    head = (ListNode *) malloc(sizeof(ListNode));

    head->data = 10;
    head->link = NULL;


#### 2번째 노드 생성

    ListNode *p;

    p = (ListNode *) malloc(sizeof(ListNode));

    p->data = 20;
    p->link = NULL;

#### 노드의 연결

head->link = p;


#### 단순 연결 리스트의 연산

- insert_first() : 리스트의 시작 부분에 항목을 삽입하는 함수이다.

- insert() : 리스트의 중간 부분에 항목을 삽입하는 함수이다.

- delete_first() : 리스트의 첫 번째 항목을 삭제하는 함수이다.

- delete() : 리스트의 중간 항목을 삭제하는 함수이다.

- print_list() : 리스트를 방문하여 모든 항목을 출력하는 함수이다.


#### 단순 연결 리스트 (삽입 연산)

    ListNode* insert_first(ListNode *head, int value) {

        ListNode *p = (ListNode *) malloc(sizeof(ListNode)); // (1)

        p->data = value; // (2)
        p->link = head; // (3)

        head = p; // (4)

        return head;

    }

    // 노드 pre 뒤에 새로운 노드 삽입

    ListNode* insert(ListNode *head, ListNode *pre, element value) {

        ListNode *p = (ListNode *) malloc(sizeof(ListNode)); // (1)

        p->data = value;    // (2)
        p->link = pre->link;    // (3)

        pre->link = p;  // (4)

        return head;    // (5)

    }


#### 단순 연결 리스트 (삭제 연산)

ListNode* delete(ListNode *head) {

    ListNode *removed;

    if (head == NULL) return NULL;

    removed = head; // (1)

    head = removed->link;   // (2)

    free(removed)

}